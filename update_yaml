#!/usr/bin/python

from lxml import etree
from pyquery import PyQuery as pq
import re
import sys

filename = 'mapr.yaml'
baseurl = 'http://maprdocs.mapr.com/home/ReferenceGuide/maprcli-REST-API-Syntax.html'

# Escape HTML text
# MapR doc bug: u'\u2013' should be '-'
def escape(text):
  return text.replace('<', '&lt;').replace('>', '&gt;').replace(u'\u2013', '-')

# Adjust spaces and line breaks
def normalize(d):
  pre_descendant = d('pre *')
  for e in d('*'):
    if e in pre_descendant:
      e.text = escape(e.text or '').replace('\n', '\n\n')
      e.tail = escape(e.tail or '').replace('\n', '\n\n')
    else:
      if e.tag == 'pre':
        e.text = escape(e.text or '').replace('\n', '\n\n')
      else:
        e.text = re.sub(r'\s+', ' ', escape(e.text or ''))
      e.tail = re.sub(r'\s+', ' ', escape(e.tail or ''))
  return d

# Replace HTML tags with Markdown
def replace_tags(d, selector, start, end, a_selector=None, a_start=None, a_end=None):
  elements = d.find(selector)
  for e in reversed(elements):
    start_tag, end_tag = start, end
    if a_selector:
      if replace_tags(pq(e), a_selector, a_start, a_end) and a_selector == 'a':
        start_tag, end_tag = '', ''
    html = escape(e.text or '')
    children = e.getchildren()
    if children:
      html += unicode('').join([etree.tostring(c) for c in children])
    href = e.get('href') or ''
    if href:
      href = '(' + href + ')'
    tail = escape(e.tail or '')
    pq(e).before(start_tag + html + end_tag + href + tail)
    parent = e.getparent()
    parent.remove(e)
  return elements

# Get the GFM representation of sub nodes
def gfm(d):
  s = d.wrap_all('<section></section>')
  normalize(s)
  replace_tags(s, 'h2', '\n\n## ', '\n\n')
  replace_tags(s, 'strong','**', '**')
  replace_tags(s, 'code', '`', '`', 'a', '[`', '`]')
  replace_tags(s, 'a', '[', ']')
  replace_tags(s, 'ul ul', '', '', 'li', '\n  * ', '\n')
  replace_tags(s, 'ul', '\n', '\n', 'li', '\n* ', '\n')
  replace_tags(s, 'ol', '\n', '\n', 'li', '\n1. ', '\n')
  replace_tags(s, 'section,td,p,div', '\n\n\n', '\n\n\n')
  replace_tags(s, 'pre', '\n\n\n```\n\n', '\n\n```\n\n\n')
  replace_tags(s, 'span', '', '')
  s('*').remove_attr('class')
  return (s.html() or '').strip()

# Print headers
def print_headers(d):

  # Print info
  f.write('swagger: "2.0"\n')
  f.write('info:\n')
  f.write('  title: MapR API\n')
  f.write('  description: The information about the MapR REST API\n')
  f.write('  contact:\n')
  f.write('    url: http://maprdocs.mapr.com\n')

  # Print version
  version = d('meta[name=version]').attr.content
  f.write('  version: "' + version + '"\n')

  # Print other headers
  f.write('basePath: /rest\n')
  f.write('schemes:\n')
  f.write('  - https\n')
  f.write('produces:\n')
  f.write('  - application/json\n')
  f.write('securityDefinitions:\n')
  f.write('  BasicAuth:\n')
  f.write('    type: basic\n')
  f.write('security:\n')
  f.write('  - BasicAuth: []\n')
  f.write('paths:\n')

# Print command
def print_command(d, tag):

  # Get command path
  syntax = d('h2,p')('*:contains("Syntax") ~ *').text().replace('\n',' ')
  match = re.search('(?<=rest)/[a-z/<>]+', syntax)
  if not match:
    return
  path = match.group().replace('<','{').replace('>','}')

  # Handle MapR doc bug
  if re.search('acl-set', d.base_url):
    path = path.replace('edit', 'set')
  if re.search('stream_edit', d.base_url):
    path = path.replace('create', 'edit')
  if re.search('stream_upstream_remove', d.base_url):
    path = path.replace('add', 'remove')
  if re.search('volume-link-create', d.base_url):
    path = path.replace('remove', 'create')

  # Print progress
  sys.stderr.write('\r\033[KProcessing ' + path + '...')

  # Print summary and description
  short_desc = d('.shortdesc') or d('p:first')
  summary = short_desc.text().replace('\n',' ')
  if short_desc.next().find('p:contains("Syntax")'):
    content = short_desc.next().children()
  else:
    content = short_desc.next_all()
  elements = []
  for e in content:
    if pq(e)('h2,p')('*:contains("Syntax")'):
      break
    elements.append(e)
  description = gfm(pq(elements))
  f.write('  ' + path + ':\n')
  f.write('    get:\n')
  f.write('      tags:\n')
  f.write('        - ' + tag + '\n')
  f.write('      summary: "' + summary + '"\n')
  f.write('      description: "' + description + '"\n')
  f.write('      externalDocs:\n')
  f.write('        url: ' + d.base_url + '\n')

  # Print parameters
  parameters = d('h2,p')('*:contains("Parameters") ~ * tbody')
  if parameters:
    f.write('      parameters:\n')
    for parameter in parameters.items('tr'):
      name = parameter('td:eq(0)').text().replace('\n',' ')

      # Handle MapR doc bug
      if name == 'virtualip end range':
        name = 'virtualipend'
      else:
        name = re.search(r'\w+', name).group()
      if name == 'json' or name == 'long':
        continue
      name = name[0].lower() + name[1:]

      description = gfm(parameter('td:eq(1)'))
      required = parameter('td:eq(0) strong')
      in_ = 'query'
      enum = []
      if re.search('urls', d.base_url) and name == 'name':
        in_ = 'path'
        required = True
        enum = [e.text for e in parameter('li')]
      f.write('        - name: ' + name + '\n')
      f.write('          in: ' + in_ + '\n')
      if re.search('"', description):
        f.write('          description: \'' + description + '\'\n')
      else:
        f.write('          description: "' + description + '"\n')
      if required:
        f.write('          required: true\n')
      f.write('          type: string\n')
      if enum:
        f.write('          enum:\n')
        for value in enum:
          f.write('            - ' + value + '\n')

  # Print responses
  f.write('      responses:\n')
  f.write('        200:\n')
  f.write('          description: OK\n')

# Main
f = open(filename, "w")
d = pq(baseurl).make_links_absolute()
print_headers(d)
category_links = d('.link:gt(0) a')
for i in category_links.items():
  d = pq(i.attr.href).make_links_absolute()
  command_links = d('.link a')
  if command_links:
    for j in command_links.items():
      d = pq(j.attr.href).make_links_absolute()
      print_command(d, i.text())
  else:
    print_command(d, i.text())
f.close()

sys.stderr.write('\r\033[K')
sys.stderr.flush()
