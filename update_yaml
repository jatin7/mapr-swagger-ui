#!/usr/bin/python

from lxml import etree
from pyquery import PyQuery as pq
import re
import sys

filename = 'mapr.yaml'
baseurl = 'http://maprdocs.mapr.com/home/ReferenceGuide/maprcli-REST-API-Syntax.html'

# Escape HTML text
# MapR doc bug: u'\u2013' should be '-'
def escape(text):
  return text.replace('<', '&lt;').replace('>', '&gt;').replace(u'\u2013', '-')

# Adjust spaces and line breaks
def normalize(d):
  pre_descendant = d('pre *')
  for e in d('*'):
    if e in pre_descendant:
      e.text = escape(e.text or '').replace('\n', '\n\n')
      e.tail = escape(e.tail or '').replace('\n', '\n\n')
    else:
      if e.tag == 'pre':
        e.text = escape(e.text or '').replace('\n', '\n\n')
      else:
        e.text = re.sub(r'\s+', ' ', escape(e.text or ''))
      e.tail = re.sub(r'\s+', ' ', escape(e.tail or ''))
  return d

# Replace HTML tags with Markdown
def replace_tags(d, selector, start, end, a_selector=None, a_start=None, a_end=None):
  elements = d.find(selector)
  for e in reversed(elements):
    start_tag, end_tag = start, end
    if a_selector:
      if replace_tags(pq(e), a_selector, a_start, a_end) and a_selector == 'a':
        start_tag, end_tag = '', ''
    html = escape(e.text or '')
    children = e.getchildren()
    if children:
      html += unicode('').join([etree.tostring(c) for c in children])
    href = e.get('href') or ''
    if href:
      href = '(' + href + ')'
    tail = escape(e.tail or '')
    pq(e).before(start_tag + html + end_tag + href + tail)
    parent = e.getparent()
    parent.remove(e)
  return elements

# Get the GFM representation of sub nodes
def gfm(d):
  s = d.wrap_all('<section></section>')
  normalize(s)
  replace_tags(s, 'h2', '\n\n## ', '\n\n')
  replace_tags(s, 'strong','**', '**')
  replace_tags(s, 'code', '`', '`', 'a', '[`', '`]')
  replace_tags(s, 'a', '[', ']')
  replace_tags(s, 'ul ul', '', '', 'li', '\n  * ', '\n')
  replace_tags(s, 'ul', '\n', '\n', 'li', '\n* ', '\n')
  replace_tags(s, 'ol', '\n', '\n', 'li', '\n1. ', '\n')
  replace_tags(s, 'section,td,p,div', '\n\n\n', '\n\n\n')
  replace_tags(s, 'pre', '\n\n\n```\n\n', '\n\n```\n\n\n')
  replace_tags(s, 'span', '', '')
  s('*').remove_attr('class')
  return (s.html() or '').strip()

# Parse enum
def parse_enum(d):
  enum = []
  if d('li'):
    for i in d('li').items():
      value = re.search(r'\w+', i.text()).group()
      if value not in enum:
        enum.append(value)
  return enum

# Print to file
def fout(text):
  f.write(text + '\n')

# Print headers
def print_headers(d):

  # Print info
  fout('swagger: "2.0"')
  fout('info:')
  fout('  title: MapR API')
  fout('  description: The information about the MapR REST API')
  fout('  contact:')
  fout('    url: http://maprdocs.mapr.com')

  # Print version
  version = d('meta[name=version]').attr.content
  fout('  version: "%s"' % version)

  # Print other headers
  fout('basePath: /rest')
  fout('schemes:')
  fout('  - https')
  fout('produces:')
  fout('  - application/json')
  fout('securityDefinitions:')
  fout('  BasicAuth:')
  fout('    type: basic')
  fout('security:')
  fout('  - BasicAuth: []')
  fout('paths:')

# Print command
def print_command(d, tag):

  # Get command path
  syntax = d('h2,p')('*:contains("Syntax") ~ *').text().replace('\n',' ')
  match = re.search('(?<=rest)/[a-z/<>]+', syntax)
  if not match:
    return
  path = match.group().replace('<','{').replace('>','}')

  # Handle MapR doc bug
  if 'acl-set' in d.base_url:
    path = path.replace('edit', 'set')
  if 'stream_edit' in d.base_url:
    path = path.replace('create', 'edit')
  if 'stream_upstream_remove' in d.base_url:
    path = path.replace('add', 'remove')
  if 'volume-link-create' in d.base_url:
    path = path.replace('remove', 'create')

  # Print progress
  sys.stderr.write('\r\033[KProcessing ' + path + '...')

  # Print summary and description
  short_desc = d('.shortdesc') or d('p:first')
  summary = short_desc.text().replace('\n',' ')
  if short_desc.next().find('p:contains("Syntax")'):
    content = short_desc.next().children()
  else:
    content = short_desc.next_all()
  elements = []
  for e in content:
    if pq(e)('h2,p')('*:contains("Syntax")'):
      break
    elements.append(e)
  description = gfm(pq(elements))
  fout('  %s:' % path)
  fout('    get:')
  fout('      tags:')
  fout('        - %s' % tag)
  fout('      summary: "%s"' % summary)
  fout('      description: "%s"' % description)
  fout('      externalDocs:')
  fout('        url: %s' % d.base_url)

  # Print parameters
  parameters = d('h2,p')('*:contains("Parameters") ~ * tbody')
  if parameters:
    fout('      parameters:')
    for parameter in parameters('tr').items():
      name = parameter('td:eq(0)').text().replace('\n',' ')

      # Handle MapR doc bug
      if name == 'virtualip end range':
        name = 'virtualipend'
      else:
        name = re.search(r'\w+', name).group()
      if name == 'json' or name == 'long':
        continue
      name = name[0].lower() + name[1:]

      description = gfm(parameter('td:eq(1)'))
      required = parameter('td:eq(0) strong')
      in_ = 'query'
      enum = []
      if 'urls' in d.base_url and name == 'name':
        in_ = 'path'
        required = True
        enum = parse_enum(parameter)
      elif name.endswith('type'):
        enum = parse_enum(parameter)
      fout('        - name: %s' % name)
      fout('          in: %s' % in_)
      if '"' in description:
        fout('          description: \'%s\'' % description)
      else:
        fout('          description: "%s"' % description)
      if required:
        fout('          required: true')
      fout('          type: string')
      if enum:
        fout('          enum:')
        for value in enum:
          fout('            - %s' % value)

  # Print responses
  fout('      responses:')
  fout('        200:')
  fout('          description: OK')

# Main
f = open(filename, "w")
d = pq(baseurl).make_links_absolute()
print_headers(d)
category_links = d('.link:gt(0) a')
for i in category_links.items():
  d = pq(i.attr.href).make_links_absolute()
  command_links = d('.link a')
  if command_links:
    for j in command_links.items():
      d = pq(j.attr.href).make_links_absolute()
      print_command(d, i.text())
  else:
    print_command(d, i.text())
f.close()

sys.stderr.write('\r\033[K')
sys.stderr.flush()
